"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sleep = exports.parseTokenAccount = exports.getTokenAccount = exports.parseMintAccount = exports.getMintInfo = exports.createAccountRentExempt = exports.createTokenAccountInstrs = exports.createTokenAccount = exports.createMintAndVault = exports.createMintInstructions = exports.createMint = exports.SPL_SHARED_MEMORY_ID = exports.connection = exports.simulateTransaction = exports.token = void 0;
const web3_js_1 = require("@solana/web3.js");
const spl_token_1 = require("@solana/spl-token");
const serum_1 = require("@project-serum/serum");
__exportStar(require("./provider"), exports);
exports.token = __importStar(require("./token"));
var simulate_transaction_1 = require("./simulate-transaction");
Object.defineProperty(exports, "simulateTransaction", { enumerable: true, get: function () { return simulate_transaction_1.simulateTransaction; } });
exports.connection = __importStar(require("./connection"));
exports.SPL_SHARED_MEMORY_ID = new web3_js_1.PublicKey('shmem4EWT2sPdVGvTZCzXXRAURL9G5vpPxNwSeKhHUL');
async function createMint(provider, authority, decimals) {
    if (authority === undefined) {
        authority = provider.wallet.publicKey;
    }
    const mint = new web3_js_1.Account();
    const instructions = await createMintInstructions(provider, authority, mint.publicKey, decimals);
    const tx = new web3_js_1.Transaction();
    tx.add(...instructions);
    await provider.send(tx, [mint]);
    return mint.publicKey;
}
exports.createMint = createMint;
async function createMintInstructions(provider, authority, mint, decimals) {
    let instructions = [
        web3_js_1.SystemProgram.createAccount({
            fromPubkey: provider.wallet.publicKey,
            newAccountPubkey: mint,
            space: 82,
            lamports: await provider.connection.getMinimumBalanceForRentExemption(82),
            programId: serum_1.TokenInstructions.TOKEN_PROGRAM_ID,
        }),
        serum_1.TokenInstructions.initializeMint({
            mint,
            decimals: decimals !== null && decimals !== void 0 ? decimals : 0,
            mintAuthority: authority,
        }),
    ];
    return instructions;
}
exports.createMintInstructions = createMintInstructions;
async function createMintAndVault(provider, amount, owner, decimals) {
    if (owner === undefined) {
        owner = provider.wallet.publicKey;
    }
    const mint = new web3_js_1.Account();
    const vault = new web3_js_1.Account();
    const tx = new web3_js_1.Transaction();
    tx.add(web3_js_1.SystemProgram.createAccount({
        fromPubkey: provider.wallet.publicKey,
        newAccountPubkey: mint.publicKey,
        space: 82,
        lamports: await provider.connection.getMinimumBalanceForRentExemption(82),
        programId: serum_1.TokenInstructions.TOKEN_PROGRAM_ID,
    }), serum_1.TokenInstructions.initializeMint({
        mint: mint.publicKey,
        decimals: decimals !== null && decimals !== void 0 ? decimals : 0,
        mintAuthority: provider.wallet.publicKey,
    }), web3_js_1.SystemProgram.createAccount({
        fromPubkey: provider.wallet.publicKey,
        newAccountPubkey: vault.publicKey,
        space: 165,
        lamports: await provider.connection.getMinimumBalanceForRentExemption(165),
        programId: serum_1.TokenInstructions.TOKEN_PROGRAM_ID,
    }), serum_1.TokenInstructions.initializeAccount({
        account: vault.publicKey,
        mint: mint.publicKey,
        owner,
    }), serum_1.TokenInstructions.mintTo({
        mint: mint.publicKey,
        destination: vault.publicKey,
        amount,
        mintAuthority: provider.wallet.publicKey,
    }));
    await provider.send(tx, [mint, vault]);
    return [mint.publicKey, vault.publicKey];
}
exports.createMintAndVault = createMintAndVault;
async function createTokenAccount(provider, mint, owner) {
    const vault = new web3_js_1.Account();
    const tx = new web3_js_1.Transaction();
    tx.add(...(await createTokenAccountInstrs(provider, vault.publicKey, mint, owner)));
    await provider.send(tx, [vault]);
    return vault.publicKey;
}
exports.createTokenAccount = createTokenAccount;
async function createTokenAccountInstrs(provider, newAccountPubkey, mint, owner, lamports) {
    if (lamports === undefined) {
        lamports = await provider.connection.getMinimumBalanceForRentExemption(165);
    }
    return [
        web3_js_1.SystemProgram.createAccount({
            fromPubkey: provider.wallet.publicKey,
            newAccountPubkey,
            space: 165,
            lamports,
            programId: serum_1.TokenInstructions.TOKEN_PROGRAM_ID,
        }),
        serum_1.TokenInstructions.initializeAccount({
            account: newAccountPubkey,
            mint,
            owner,
        }),
    ];
}
exports.createTokenAccountInstrs = createTokenAccountInstrs;
async function createAccountRentExempt(provider, programId, size) {
    const acc = new web3_js_1.Account();
    const tx = new web3_js_1.Transaction();
    tx.add(web3_js_1.SystemProgram.createAccount({
        fromPubkey: provider.wallet.publicKey,
        newAccountPubkey: acc.publicKey,
        space: size,
        lamports: await provider.connection.getMinimumBalanceForRentExemption(size),
        programId,
    }));
    await provider.send(tx, [acc]);
    return acc;
}
exports.createAccountRentExempt = createAccountRentExempt;
async function getMintInfo(provider, addr) {
    let depositorAccInfo = await provider.connection.getAccountInfo(addr);
    if (depositorAccInfo === null) {
        throw new Error('Failed to find token account');
    }
    return parseMintAccount(depositorAccInfo.data);
}
exports.getMintInfo = getMintInfo;
function parseMintAccount(data) {
    const m = spl_token_1.MintLayout.decode(data);
    m.mintAuthority = new web3_js_1.PublicKey(m.mintAuthority);
    m.supply = spl_token_1.u64.fromBuffer(m.supply);
    m.isInitialized = m.state !== 0;
    return m;
}
exports.parseMintAccount = parseMintAccount;
async function getTokenAccount(provider, addr) {
    let depositorAccInfo = await provider.connection.getAccountInfo(addr);
    if (depositorAccInfo === null) {
        throw new Error('Failed to find token account');
    }
    return parseTokenAccount(depositorAccInfo.data);
}
exports.getTokenAccount = getTokenAccount;
function parseTokenAccount(data) {
    const accountInfo = spl_token_1.AccountLayout.decode(data);
    accountInfo.mint = new web3_js_1.PublicKey(accountInfo.mint);
    accountInfo.owner = new web3_js_1.PublicKey(accountInfo.owner);
    accountInfo.amount = spl_token_1.u64.fromBuffer(accountInfo.amount);
    if (accountInfo.delegateOption === 0) {
        accountInfo.delegate = null;
        // eslint-disable-next-line new-cap
        accountInfo.delegatedAmount = new spl_token_1.u64(0);
    }
    else {
        accountInfo.delegate = new web3_js_1.PublicKey(accountInfo.delegate);
        accountInfo.delegatedAmount = spl_token_1.u64.fromBuffer(accountInfo.delegatedAmount);
    }
    accountInfo.isInitialized = accountInfo.state !== 0;
    accountInfo.isFrozen = accountInfo.state === 2;
    if (accountInfo.isNativeOption === 1) {
        accountInfo.rentExemptReserve = spl_token_1.u64.fromBuffer(accountInfo.isNative);
        accountInfo.isNative = true;
    }
    else {
        accountInfo.rentExemptReserve = null;
        accountInfo.isNative = false;
    }
    if (accountInfo.closeAuthorityOption === 0) {
        accountInfo.closeAuthority = null;
    }
    else {
        accountInfo.closeAuthority = new web3_js_1.PublicKey(accountInfo.closeAuthority);
    }
    return accountInfo;
}
exports.parseTokenAccount = parseTokenAccount;
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
exports.sleep = sleep;
//# sourceMappingURL=index.js.map