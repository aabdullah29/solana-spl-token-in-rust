"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetMultipleAccountsAndContextRpcResult = exports.getMultipleSolanaAccounts = void 0;
const web3_js_1 = require("@solana/web3.js");
const superstruct_1 = require("superstruct");
const assert_1 = __importDefault(require("assert"));
async function getMultipleSolanaAccounts(connection, publicKeys) {
    const args = [publicKeys.map(k => k.toBase58()), { commitment: 'recent' }];
    // @ts-ignore
    const unsafeRes = await connection._rpcRequest('getMultipleAccounts', args);
    const res = exports.GetMultipleAccountsAndContextRpcResult(unsafeRes);
    if (res.error) {
        throw new Error('failed to get info about accounts ' +
            publicKeys.map(k => k.toBase58()).join(', ') +
            ': ' +
            res.error.message);
    }
    assert_1.default(typeof res.result !== 'undefined');
    const accounts = [];
    for (const account of res.result.value) {
        let value = null;
        if (res.result.value) {
            const { executable, owner, lamports, data } = account;
            assert_1.default(data[1] === 'base64');
            value = {
                executable,
                owner: new web3_js_1.PublicKey(owner),
                lamports,
                data: Buffer.from(data[0], 'base64'),
            };
        }
        if (value === null) {
            throw new Error('Invalid response');
        }
        accounts.push(value);
    }
    return accounts.map((account, idx) => {
        return {
            publicKey: publicKeys[idx],
            account,
        };
    });
}
exports.getMultipleSolanaAccounts = getMultipleSolanaAccounts;
function jsonRpcResult(resultDescription) {
    const jsonRpcVersion = superstruct_1.struct.literal('2.0');
    return superstruct_1.struct.union([
        superstruct_1.struct({
            jsonrpc: jsonRpcVersion,
            id: 'string',
            error: 'any',
        }),
        superstruct_1.struct({
            jsonrpc: jsonRpcVersion,
            id: 'string',
            error: 'null?',
            result: resultDescription,
        }),
    ]);
}
function jsonRpcResultAndContext(resultDescription) {
    return jsonRpcResult({
        context: superstruct_1.struct({
            slot: 'number',
        }),
        value: resultDescription,
    });
}
const AccountInfoResult = superstruct_1.struct({
    executable: 'boolean',
    owner: 'string',
    lamports: 'number',
    data: 'any',
    rentEpoch: 'number?',
});
exports.GetMultipleAccountsAndContextRpcResult = jsonRpcResultAndContext(superstruct_1.struct.array([superstruct_1.struct.union(['null', AccountInfoResult])]));
//# sourceMappingURL=connection.js.map