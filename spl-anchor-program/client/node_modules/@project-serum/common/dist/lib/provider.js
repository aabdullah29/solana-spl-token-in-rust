"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeWallet = exports.Provider = void 0;
const web3_js_1 = require("@solana/web3.js");
const simulate_transaction_1 = require("./simulate-transaction");
class Provider {
    constructor(connection, wallet, opts) {
        this.connection = connection;
        this.wallet = wallet;
        this.opts = opts;
    }
    static defaultOptions() {
        return {
            preflightCommitment: 'recent',
            commitment: 'recent',
        };
    }
    static local(url, opts) {
        opts = opts || Provider.defaultOptions();
        const connection = new web3_js_1.Connection(url || 'http://localhost:8899', opts.preflightCommitment);
        const wallet = NodeWallet.local();
        return new Provider(connection, wallet, opts);
    }
    async send(tx, signers, opts) {
        var _a;
        if (signers === undefined) {
            signers = [];
        }
        if (opts === undefined) {
            opts = this.opts;
        }
        const signerKps = signers.filter(s => s !== undefined);
        const signerPubkeys = [this.wallet.publicKey].concat(signerKps.map(s => s.publicKey));
        tx.setSigners(...signerPubkeys);
        tx.recentBlockhash = (await this.connection.getRecentBlockhash(opts.preflightCommitment)).blockhash;
        await this.wallet.signTransaction(tx);
        signerKps.forEach(kp => {
            tx.partialSign(kp);
        });
        const rawTx = tx.serialize();
        try {
            const txId = await web3_js_1.sendAndConfirmRawTransaction(this.connection, rawTx, opts);
            return txId;
        }
        catch (err) {
            console.error('Transaction failed. Simulating for logs...');
            const r = await simulate_transaction_1.simulateTransaction(this.connection, tx, (_a = opts.commitment) !== null && _a !== void 0 ? _a : 'recent');
            console.error(r);
            throw err;
        }
    }
    async sendAll(reqs, opts) {
        var _a;
        if (opts === undefined) {
            opts = this.opts;
        }
        const blockhash = await this.connection.getRecentBlockhash(opts.preflightCommitment);
        let txs = reqs.map(r => {
            let tx = r.tx;
            let signers = r.signers;
            if (signers === undefined) {
                signers = [];
            }
            const signerKps = signers.filter(s => s !== undefined);
            const signerPubkeys = [this.wallet.publicKey].concat(signerKps.map(s => s.publicKey));
            tx.setSigners(...signerPubkeys);
            tx.recentBlockhash = blockhash.blockhash;
            signerKps.forEach(kp => {
                tx.partialSign(kp);
            });
            return tx;
        });
        const signedTxs = await this.wallet.signAllTransactions(txs);
        const sigs = [];
        for (let k = 0; k < txs.length; k += 1) {
            const tx = signedTxs[k];
            const rawTx = tx.serialize();
            try {
                sigs.push(await web3_js_1.sendAndConfirmRawTransaction(this.connection, rawTx, opts));
            }
            catch (err) {
                console.error('Transaction failed. Simulating for logs...');
                const r = await simulate_transaction_1.simulateTransaction(this.connection, tx, (_a = opts.commitment) !== null && _a !== void 0 ? _a : 'recent');
                console.error(r);
                throw err;
            }
        }
        return sigs;
    }
}
exports.Provider = Provider;
class NodeWallet {
    constructor(payer) {
        this.payer = payer;
    }
    static local() {
        const payer = new web3_js_1.Account(Buffer.from(JSON.parse(require('fs').readFileSync(require('os').homedir() + '/.config/solana/id.json', {
            encoding: 'utf-8',
        }))));
        return new NodeWallet(payer);
    }
    async signTransaction(tx) {
        tx.partialSign(this.payer);
        return tx;
    }
    async signAllTransactions(txs) {
        return txs.map(t => {
            t.partialSign(this.payer);
            return t;
        });
    }
    get publicKey() {
        return this.payer.publicKey;
    }
}
exports.NodeWallet = NodeWallet;
//# sourceMappingURL=provider.js.map